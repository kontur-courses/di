	Задача №4 - ООП осень

	Необходимо на основе результатов выполнения прошлой задачи Lexer разработать механизм, позволяющий осуществлять трансляцию исходных кодов пограмм с одного языка на другой. Каждый поддерживаемый язык регистрируется в трансляторе. После регистрации языка транслятор должен уметь транслировать в этот язык, а затем транслировать из него же в другой. В данной задаче требуется реализовать трансляцию двух языков: Java и Pascal.
Пример:

	Translator tr = new Translator(); //создаем непосредственно сам транслятор
	
	ILanguage pascal = new PascalLang(); //создаем то, что называется "язык" в данной задаче. А именно набор правил и 					     //согалшений, удовлетворяющих некоторому интерфейсу
	pascal.register(new PascalForTranslator()); //регистрируем "мини-транслятор", который способен работать только с циклом for
	pascal.register(new PascalVarTranslator()); //регистрируем "мини-транслятор", который способен работать только с переменными
	//аналогично для Java
	Ilanguage java = new JavaLang();
	java.register(new JavaForTranslator());
	java.register(new JavavVarTranslator());

	tr.register("pascal", pascal); //регистрация самого языка происходит по типу ключ-значение
	tr.register("java", java); //регистрация самого языка происходит по типу ключ-значение

	Token[] tokens = tr.translate("java", "pascal", source); //пример вызова метода тарнсляции. Указывается исходный язык, целевой, исходный текст программы.

	
	После трансляции необходимо из новых токенов собрать исходный текст программы.

	ТРЕБОВАНИЯ:
1. Осуществить транлсяцию точки входа в приложение - после трансляции должен получаться компилируемый текст программы.
2. Осуществить трансляцию минимально необходимого набора лексем для тестовой программы. Тестовая программа прилагается в архиве.
3. Поддерживать сколь угодно глубокий уровень вложенности одних токенов в другие при условии отсутствия неподдерживаемых лексем.
4. Должна быть возможность транслировать из каждого зарегистрированнного языка в каждый зарегистрированный, при этом регистрация нового языка не должна требовать изменений в других. 
5. Подготовить среду для компиляции программ на Pascal и Java.
6. ВАЖНО: Наращивание функциональности транслятора осуществляется с использованием "мини-трансляторов" в каждом конкретном языке. Следовательно, как и задаче Lexer, расширение возможностей транслятора происходит через добавление функциональных единиц логики без изменения PascalLang или JavaLang. Иными словами, организация транслятора должна быть такой, чтобы добавление новой поддерживаемой конструкции сводилось к добавлению "мини-транслятора" в каждый язык без изменения всего остального.(полная аналогия с ридерами в Lexer'е, где функциональноть Lexer'а расширялась через новые ридеры)

	ЗАМЕЧАНИЯ:
1. Для удобства выполнения пункта требований №3 можно ввести понятие "дочерний токен" и наделить каждый токен следующим полем:
	Token[] children - набор под-токенов. 
   Введение иерархии позволит работать с вложенностью конструкций, если принять, что дочерними токенами являются все токены между открывающим и закрывающим оператором.
	Пример: тело цикла for есть дочерние токены самого токена for.

2. Для реализации пункта требований №4 будет удобно осуществлять трансляцию не из конкретного языка в конкретный язык, а транслировать из языка во внутренний псевдокод, а из него уже транслировать в целевой язык.

3. Удобно будет ввести понятие "тип токена".

	ЗАДАЧИ НА *:

1. Автоматическое определение исходного языка трансляции.
2. Прогон полного цикла: трансляция в другой язык, компиляция, выполнение, возврат результата в среду исходного языка и вывод на консоль.
3. Поддержка бОльшего количества лексем, чем минимально необходимо.
4. Добавление третьего языка и демонстрация трехсторонней трансляции.

	ЗАКЛЮЧЕНИЕ:
  В рамках задачи необходимо использовать правильные решения, которые позволили бы организовать код таким образом, чтобы максиммально отделить алгоритмы от непосредственных данных. В первую очередь будет оцениваться стройность кода,а не сам факт успешной трансляции либо огромное количество поддерживаемых лексем. В первую очередь важна структура программы.
														