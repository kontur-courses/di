# Задание TagsCloudContainer

Сделай fork этого репозитория и работай в нем.

Нужно сделать приложение генератора [облака слов](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D0%BB%D0%B0%D0%BA%D0%BE_%D1%82%D0%B5%D0%B3%D0%BE%D0%B2) по произвольному тексту.
[Примеры](https://www.google.ru/search?q=%D0%9E%D0%B1%D0%BB%D0%B0%D0%BA%D0%BE+%D1%81%D0%BB%D0%BE%D0%B2&tbm=isch).

В облаке не должно быть повторяющихся слов, размер слова должен быть тем больше, чем чаще встречается слово, не должно быть "скучных" слов (предлогов, местоимений, ...).

Используй алгоритм из блока про [TDD](https://github.com/kontur-csharper/tdd).

## Дополнительные ограничения

### Точки расширения

В промышленном программировании при разработке далеко не всегда разумно создавать точки расширения "на будущее". 
Чаще руководствуются принципами YAGNI и KISS, поддерживая код как можно проще, а абстракции создаются и внедряются в код только в момент, 
когда понадобилось расширить функциональность.

Тем не менее для учебных целей в этой задаче требуется заранее предусмотреть точки расширения для наиболее вероятных потенциальных изменений в твоем продукте.
Результат твоей работы должен быть расширяем без модификации уже имеющегося кода (Принцип OCP).

### Полиморфизм вместо условных операторов

Запрещено использовать операторы if, switch, ?: и прочие условные операторы, если их можно заменить полиморфизмом.

### Dependency injection

Для сборки зависимостей используй любой DI Container, отличный от Ninject. 
Довольно распространенные контейнеры — Autofac и Castle Windsor.

### Тесты

Все нетривиальные части покрой модульными тестами.
Добавь несколько более крупных тестов, проверяющих работу всей программы в сборе.

## Требования к функциональности и их возможные изменения

Ниже описаны обязательные пункты и пункты на перспективу. 
Выполни обязательные требования, а потом выбери и реализуй несколько понравившихся пунктов на перспективу.

Даже если требование из перспективы не выполнено, соответствующая точка расширения в вашем коде уже должна быть.

### Исходный текст 

* Источником данных должен быть файл со словами по одному в строке.
* В перспективе — поддерживать разные форматы файлов (txt, doc, docx, ...)

### Предобработка слов

* На этапе предобработки, приведи все слова к нижнему регистру и исключи скучные слова
* В перспективе — дать возможность влиять на список скучных слов, которые не попадут в облако.
* В перспективе — поддерживать ввод данных из литературного текста, с приведением слов в начальную форму.
* В перспективе — дать возможность выбирать только определенные части речи (например, только существительные)

### Формат результата

* В качестве результата программа должна генерировать png-файл. 
* Должна быть возможность задать цвета, шрифт и размер изображения.
* В перспективе — поддерживать разные форматы изображений.
* В перспективе — поддерживать разные алгоритмы расцветки слов.

### Алгоритм

* Сделай так, чтобы по одному тексту можно было сгенерировать несколько облаков тегов с помощью разных алгоритмов или одного алгоритма с разными настройками.
* В перспективе — реализовать несколько алгоритмов формирования облака тегов.

### GUI или Console

* Организуй код так, чтобы было легко сделать оба вида клиентов — и клиента командной строки, и GUI приложение с вводом параметров и интерактивным просмотром.
* Реализуй одного клиента по выбору.
* В перспективе — реализуй второго.



## Дополнительные ссылки

* Библиотеки для разбора аргументов командной строки:
	
	* https://github.com/gsscoder/commandline
	* https://github.com/docopt/docopt.net

* Приведение слова к начальной форме и определение частей речи:
	
	* Библиотека NHunspell http://www.crawler-lib.net/nhunspell
	* Утилита командной строки MyStem https://tech.yandex.ru/mystem/doc/usage-examples-docpage/
	
	
